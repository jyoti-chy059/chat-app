"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var lodash = require("lodash");
var util = require("util");
var debug_assert_1 = require("../util/debug-assert");
var isEmpty = lodash.isEmpty;
var status_message_1 = require("../../client/stackdriver/status-message");
var assert = debug_assert_1.debugAssert(!!process.env.CLOUD_DEBUG_ASSERTIONS);
// Error message indices into the resolved variable table.
var BUFFER_FULL_MESSAGE_INDEX = 0;
var NATIVE_PROPERTY_MESSAGE_INDEX = 1;
var GETTER_MESSAGE_INDEX = 2;
var ARG_LOCAL_LIMIT_MESSAGE_INDEX = 3;
/**
 * Checks that the provided expressions will not have side effects and
 * then evaluates the expression in the current execution context.
 *
 * @return an object with error and mirror fields.
 */
function evaluate(expression, frame, v8inspector, returnByValue) {
    // First validate the expression to make sure it doesn't mutate state
    // and ask V8 Inspector to evaluate the expression
    var result = v8inspector.evaluateOnCallFrame({
        callFrameId: frame.callFrameId,
        expression: expression,
        returnByValue: returnByValue,
        throwOnSideEffect: true
    });
    if (result.error || !result.response) {
        return {
            error: result.error ? String(result.error) : 'no reponse in result'
        };
    }
    else if (result.response.exceptionDetails) {
        return { error: String(result.response.result.description).split('\n')[0] };
    }
    else {
        return { error: null, object: result.response.result };
    }
}
exports.evaluate = evaluate;
var StateResolver = /** @class */ (function () {
    /**
     * @param {Array<!Object>} callFrames
     * @param {Array<string>} expressions
     * @param {!Object} config
     * @constructor
     */
    function StateResolver(callFrames, breakpoint, config, scriptmapper, v8Inspector) {
        this.callFrames = callFrames;
        this.breakpoint = breakpoint;
        // TODO: Investigate whether this cast can be avoided.
        this.expressions = breakpoint.expressions;
        this.config = config;
        this.scriptmapper = scriptmapper;
        this.v8Inspector = v8Inspector;
        this.evaluatedExpressions = [];
        this.totalSize = 0;
        this.messageTable = [];
        this.messageTable[BUFFER_FULL_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Max data size reached', true)
        };
        this.messageTable[NATIVE_PROPERTY_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Native properties are not available', true)
        };
        this.messageTable[GETTER_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Properties with getters are not available', true)
        };
        this.messageTable[ARG_LOCAL_LIMIT_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Locals and arguments are only displayed for the ' +
                'top `config.capture.maxExpandFrames=' +
                config.capture.maxExpandFrames + '` stack frames.', true)
        };
        // TODO: Determine why _extend is used here
        this.resolvedVariableTable =
            util._extend([], this.messageTable);
        this.rawVariableTable = this.messageTable.map(function () {
            return null;
        });
    }
    /**
     * Captures the stack and current execution state.
     *
     * @return an object with stackFrames, variableTable, and
     *         evaluatedExpressions fields
     */
    StateResolver.prototype.capture_ = function () {
        var _this = this;
        // Evaluate the watch expressions
        var evalIndexSet = new Set();
        if (this.expressions) {
            this.expressions.forEach(function (expression, index2) {
                var result = evaluate(expression, _this.callFrames[0], _this.v8Inspector, false);
                var evaluated;
                if (result.error) {
                    evaluated = {
                        name: expression,
                        status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, result.error, true)
                    };
                }
                else {
                    // TODO: Determine how to not downcast this to v8Types.ValueMirror
                    // TODO: Handle the case where `result.mirror` is `undefined`.
                    evaluated = _this.resolveVariable_(expression, result.object, true);
                    var varTableIdx = evaluated.varTableIndex;
                    if (typeof varTableIdx !== 'undefined') {
                        evalIndexSet.add(varTableIdx);
                    }
                }
                _this.evaluatedExpressions[index2] = evaluated;
            });
        }
        // The frames are resolved after the evaluated expressions so that
        // evaluated expressions can be evaluated as much as possible within
        // the max data size limits
        var frames = this.resolveFrames_();
        // Now resolve the variables
        var index = this.messageTable.length; // skip the sentinel values
        var noLimit = this.config.capture.maxDataSize === 0;
        while (index <
            this.rawVariableTable.length && // NOTE: length changes in loop
            (this.totalSize < this.config.capture.maxDataSize || noLimit)) {
            assert.ok(!this.resolvedVariableTable[index]); // shouldn't have it
            // resolved yet
            var isEvaluated = evalIndexSet.has(index);
            // TODO: Handle the cases where `null` or `undefined` occurs
            if (this.rawVariableTable[index].objectId) {
                this.resolvedVariableTable[index] = this.resolveRemoteObject_(this.rawVariableTable[index], isEvaluated);
            }
            index++;
        }
        // If we filled up the buffer already, we need to trim the remainder
        if (index < this.rawVariableTable.length) {
            this.trimVariableTable_(index, frames);
        }
        return {
            id: this.breakpoint.id,
            stackFrames: frames,
            variableTable: this.resolvedVariableTable,
            evaluatedExpressions: this.evaluatedExpressions
        };
    };
    /**
     * Limits the size of the variable table to `fromIndex` elements. It marks
     * all variables with entries beyond `fromIndex` with a message indicating
     * that the table filled.
     *
     * @param {Number} fromIndex The desired size of the variable table.
     * @param {Object} frames Frames associated with the current execution
     *                        environment.
     */
    StateResolver.prototype.trimVariableTable_ = function (fromIndex, frames) {
        this.resolvedVariableTable.splice(fromIndex); // remove the remaining entries
        var that = this;
        var processBufferFull = function (variables) {
            variables.forEach(function (variable) {
                if (variable.varTableIndex && variable.varTableIndex >= fromIndex) {
                    // make it point to the sentinel 'buffer full' value
                    variable.varTableIndex = BUFFER_FULL_MESSAGE_INDEX;
                    variable.status = that.messageTable[BUFFER_FULL_MESSAGE_INDEX].status;
                }
                if (variable.members) {
                    processBufferFull(variable.members);
                }
            });
        };
        frames.forEach(function (frame) {
            processBufferFull(frame.arguments);
            processBufferFull(frame.locals);
        });
        processBufferFull(this.evaluatedExpressions);
        processBufferFull(this.resolvedVariableTable);
    };
    StateResolver.prototype.resolveFrames_ = function () {
        var frames = [];
        var frameCount = Math.min(this.callFrames.length, this.config.capture.maxFrames);
        for (var i = 0; i < frameCount; i++) {
            var frame = this.callFrames[i];
            if (this.shouldFrameBeResolved_(frame)) {
                frames.push(this.resolveFrame_(frame, (i < this.config.capture.maxExpandFrames)));
            }
        }
        return frames;
    };
    StateResolver.prototype.shouldFrameBeResolved_ = function (frame) {
        // Only capture data from the frames for which we can link the data back
        // to the source files.
        var fullPath = this.resolveFullPath_(frame);
        if (!this.isPathInCurrentWorkingDirectory_(fullPath)) {
            return false;
        }
        var relativePath = this.resolveRelativePath_(frame);
        if (!this.config.capture.includeNodeModules &&
            this.isPathInNodeModulesDirectory_(relativePath)) {
            return false;
        }
        return true;
    };
    StateResolver.prototype.resolveFullPath_ = function (frame) {
        var scriptId = frame.location.scriptId;
        if (this.scriptmapper[scriptId] === undefined) {
            return '';
        }
        if (this.scriptmapper[scriptId].url === undefined) {
            return '';
        }
        return this.scriptmapper[scriptId].url;
    };
    StateResolver.prototype.resolveRelativePath_ = function (frame) {
        var fullPath = this.resolveFullPath_(frame);
        return this.stripCurrentWorkingDirectory_(fullPath);
    };
    StateResolver.prototype.stripCurrentWorkingDirectory_ = function (path) {
        // Strip 1 extra character to remove the slash.
        return path.substr((this.config.workingDirectory).length + 1);
    };
    StateResolver.prototype.isPathInCurrentWorkingDirectory_ = function (path) {
        // return true;
        return path.indexOf(this.config.workingDirectory) === 0;
    };
    StateResolver.prototype.isPathInNodeModulesDirectory_ = function (path) {
        return path.indexOf('node_modules') === 0;
    };
    StateResolver.prototype.resolveFrame_ = function (frame, underFrameCap) {
        var args = [];
        var locals = [];
        if (!underFrameCap) {
            args.push({
                name: 'arguments_not_available',
                varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX
            });
            locals.push({
                name: 'locals_not_available',
                varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX
            });
        }
        else {
            locals = this.resolveLocalsList_(frame);
            if (isEmpty(locals)) {
                locals = [];
            }
        }
        return {
            function: this.resolveFunctionName_(frame),
            location: this.resolveLocation_(frame),
            arguments: args,
            locals: locals
        };
    };
    StateResolver.prototype.resolveFunctionName_ = function (frame) {
        if (!frame) {
            return '';
        }
        if (frame.functionName === '') {
            return '(anonymous function)';
        }
        return frame.functionName;
    };
    StateResolver.prototype.resolveLocation_ = function (frame) {
        return {
            path: this.resolveRelativePath_(frame),
            line: frame.location.lineNumber
        };
    };
    /**
     * Iterates and returns variable information for all scopes (excluding global)
     * in a given frame. FrameMirrors should return their scope object list with
     * most deeply nested scope first so variables initially encountered will take
     * precedence over subsequent instance with the same name - this is tracked in
     * the usedNames map. The argument list given to this function may be
     * manipulated if variables with a deeper scope occur which have the same
     * name.
     * @function resolveLocalsList_
     * @memberof StateResolver
     * @param {inspector.Debugger.CallFrame} frame - A instance of callframe.
     * @returns {Array<Object>} - returns an array containing data about selected
     *  variables
     */
    StateResolver.prototype.resolveLocalsList_ = function (frame) {
        var locals = [];
        var usedNames = {};
        var allScopes = frame.scopeChain;
        var count = allScopes.length;
        // We find the top-level (module global) variable pollute the local
        // variables we omit them by default, unless the breakpoint itself is
        // top-level. The last scope is always omitted.
        if (frame.scopeChain[count - 2].type === 'closure') {
            count -= 2;
        }
        else {
            count -= 1;
        }
        for (var i = 0; i < count; ++i) {
            var result = this.v8Inspector.getProperties({ objectId: frame.scopeChain[i].object.objectId });
            // TODO: Handle when result.error exists.
            if (result.response && !isEmpty(result.response.result)) {
                for (var j = 0; j < result.response.result.length; ++j) {
                    if (!usedNames[result.response.result[j].name]) {
                        // It's a valid variable that belongs in the locals list
                        // and wasn't discovered at a lower-scope
                        usedNames[result.response.result[j].name] = true;
                        if (result.response.result[j].value) {
                            locals.push(this.resolveVariable_(result.response.result[j].name, result.response.result[j].value, false));
                        }
                    }
                }
            }
        }
        if (frame.this.objectId) {
            locals.push(this.resolveVariable_('context', frame.this, false));
        }
        return locals;
    };
    /**
     * Computes a text representation of the provided value based on its type.
     * If the value is a recursive data type, it will be represented as an index
     * into the variable table.
     *
     * @param {String} name The name of the variable.
     * @param {Object} object A RemoteObject from v8 Runtime.
     * @param {boolean} isEvaluated Specifies if the variable is from a watched
     *                              expression.
     */
    StateResolver.prototype.resolveVariable_ = function (name, object, isEvaluated) {
        var size = name.length;
        var data = { name: name };
        if (this.isPrimitive_(object.type)) {
            // primitives: undefined, null, boolean, number, string, symbol
            data.value = String(object.value);
            var maxLength = this.config.capture.maxStringLength;
            if (!isEvaluated && maxLength && maxLength < data.value.length) {
                data.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Only first `config.capture.maxStringLength=' +
                    this.config.capture.maxStringLength +
                    '` chars were captured for string of length ' +
                    data.value.length +
                    '. Use in an expression to see the full string.', false);
                data.value = data.value.substring(0, maxLength) + '...';
            }
        }
        else if (this.isFunction_(object.type)) {
            data.value =
                'function ' + (name === '' ? '(anonymous function)' : name + '()');
        }
        else if (this.isObject_(object.type)) {
            data.varTableIndex = this.getVariableIndex_(object);
        }
        else {
            data.value = 'unknown type';
        }
        if (data.value) {
            size += data.value.length;
        }
        else {
            size += 8; // fudge-it
        }
        this.totalSize += size;
        return data;
    };
    StateResolver.prototype.isPrimitive_ = function (type) {
        return type === 'undefined' || type === 'boolean' || type === 'number' ||
            type === 'string' || type === 'symbol';
    };
    StateResolver.prototype.isObject_ = function (type) {
        return type === 'object';
    };
    StateResolver.prototype.isFunction_ = function (type) {
        return type === 'function';
    };
    StateResolver.prototype.getVariableIndex_ = function (value) {
        var idx = this.rawVariableTable.indexOf(value);
        if (idx === -1) {
            idx = this.storeObjectToVariableTable_(value);
        }
        return idx;
    };
    StateResolver.prototype.storeObjectToVariableTable_ = function (obj) {
        var idx = this.rawVariableTable.length;
        this.rawVariableTable[idx] = obj;
        return idx;
    };
    /**
     * Responsible for recursively resolving the properties on a
     * provided remote object.
     */
    StateResolver.prototype.resolveRemoteObject_ = function (object, isEvaluated) {
        var maxProps = this.config.capture.maxProperties;
        var result = this.v8Inspector.getProperties({ objectId: object.objectId });
        var members = [];
        if (result.error || !result.response) {
            members.push({
                name: result.error ? String(result.error) :
                    'no response got in getProperty'
            });
        }
        else {
            var truncate = maxProps && result.response.result.length > maxProps;
            var upperBound = result.response.result.length;
            if (!isEvaluated && truncate)
                upperBound = maxProps;
            for (var i = 0; i < upperBound; ++i) {
                if (result.response.result[i].isOwn) {
                    members.push(this.resolveObjectProperty_(isEvaluated, result.response.result[i]));
                }
                else {
                    truncate = false;
                }
            }
            if (!isEvaluated && truncate) {
                members.push({
                    name: 'Only first `config.capture.maxProperties=' +
                        this.config.capture.maxProperties +
                        '` properties were captured. Use in an expression' +
                        ' to see all properties.'
                });
            }
        }
        return { value: object.description, members: members };
    };
    StateResolver.prototype.resolveObjectProperty_ = function (isEvaluated, property) {
        var name = String(property.name);
        if (property.get !== undefined) {
            return { name: name, varTableIndex: GETTER_MESSAGE_INDEX };
        }
        // TODO: Handle the case when property.value is undefined
        return this.resolveVariable_(name, property.value, isEvaluated);
    };
    return StateResolver;
}());
// This function is used by unit tests to make sure assertions are enabled.
function testAssert() {
    assert.equal(0, 1);
}
exports.testAssert = testAssert;
/**
 * Captures the stack and current execution state.
 *
 * @return an object with stackFrames, variableTable, and
 *         evaluatedExpressions fields
 */
function capture(callFrames, breakpoint, config, scriptmapper, v8Inspector) {
    return (new StateResolver(callFrames, breakpoint, config, scriptmapper, v8Inspector))
        .capture_();
}
exports.capture = capture;
//# sourceMappingURL=inspector-state.js.map