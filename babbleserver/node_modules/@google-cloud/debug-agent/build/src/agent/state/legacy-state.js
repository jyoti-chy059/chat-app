"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var lodash = require("lodash");
var util = require("util");
var vm = require("vm");
var debug_assert_1 = require("../util/debug-assert");
var transform = lodash.transform;
var flatten = lodash.flatten;
var isEmpty = lodash.isEmpty;
var status_message_1 = require("../../client/stackdriver/status-message");
// TODO: Determine if `ScopeType` should be named `scopeType`.
// tslint:disable-next-line:variable-name
var ScopeType = vm.runInDebugContext('ScopeType');
var assert = debug_assert_1.debugAssert(!!process.env.CLOUD_DEBUG_ASSERTIONS);
// Error message indices into the resolved variable table.
var BUFFER_FULL_MESSAGE_INDEX = 0;
var NATIVE_PROPERTY_MESSAGE_INDEX = 1;
var GETTER_MESSAGE_INDEX = 2;
var ARG_LOCAL_LIMIT_MESSAGE_INDEX = 3;
/**
 * Checks that the provided expressions will not have side effects and
 * then evaluates the expression in the current execution context.
 *
 * @return an object with error and mirror fields.
 */
function evaluate(expression, frame) {
    // First validate the expression to make sure it doesn't mutate state
    var acorn = require('acorn');
    try {
        var ast = acorn.parse(expression, { sourceType: 'script' });
        var validator = require('../util/validator');
        if (!validator.isValid(ast)) {
            return { error: 'Expression not allowed' };
        }
    }
    catch (err) {
        return { error: err.message };
    }
    // Now actually ask V8 to evaluate the expression
    try {
        var mirror = frame.evaluate(expression);
        return { error: null, mirror: mirror };
    }
    catch (error) {
        return { error: error };
    }
}
exports.evaluate = evaluate;
var StateResolver = /** @class */ (function () {
    /**
     * @param {!Object} execState
     * @param {Array<string>} expressions
     * @param {!Object} config
     * @constructor
     */
    function StateResolver(execState, expressions, config, v8debug) {
        this.state = execState;
        this.expressions = expressions;
        this.config = config;
        this.ctx = v8debug;
        this.evaluatedExpressions = [];
        this.totalSize = 0;
        this.messageTable = [];
        this.messageTable[BUFFER_FULL_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Max data size reached', true)
        };
        this.messageTable[NATIVE_PROPERTY_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Native properties are not available', true)
        };
        this.messageTable[GETTER_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Properties with getters are not available', true)
        };
        this.messageTable[ARG_LOCAL_LIMIT_MESSAGE_INDEX] = {
            status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Locals and arguments are only displayed for the ' +
                'top `config.capture.maxExpandFrames=' +
                config.capture.maxExpandFrames + '` stack frames.', true)
        };
        // TODO: Determine why _extend is used here
        this.resolvedVariableTable =
            util._extend([], this.messageTable);
        this.rawVariableTable = this.messageTable.map(function () {
            return null;
        });
    }
    /**
     * Captures the stack and current execution state.
     *
     * @return an object with stackFrames, variableTable, and
     *         evaluatedExpressions fields
     */
    StateResolver.prototype.capture_ = function () {
        var that = this;
        // Evaluate the watch expressions
        var evalIndexSet = new Set();
        if (that.expressions) {
            that.expressions.forEach(function (expression, index2) {
                var result = evaluate(expression, that.state.frame(0));
                var evaluated;
                if (result.error) {
                    evaluated = {
                        name: expression,
                        status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, result.error, true)
                    };
                }
                else {
                    // TODO: Determine how to not downcast this to v8.ValueMirror
                    // TODO: Handle the case where `result.mirror` is `undefined`.
                    evaluated = that.resolveVariable_(expression, result.mirror, true);
                    var varTableIdx = evaluated.varTableIndex;
                    if (typeof varTableIdx !== 'undefined') {
                        evalIndexSet.add(varTableIdx);
                    }
                }
                that.evaluatedExpressions[index2] = evaluated;
            });
        }
        // The frames are resolved after the evaluated expressions so that
        // evaluated expressions can be evaluated as much as possible within
        // the max data size limits
        var frames = that.resolveFrames_();
        // Now resolve the variables
        var index = this.messageTable.length; // skip the sentinel values
        var noLimit = that.config.capture.maxDataSize === 0;
        while (index <
            that.rawVariableTable.length && // NOTE: length changes in loop
            (that.totalSize < that.config.capture.maxDataSize || noLimit)) {
            assert.ok(!that.resolvedVariableTable[index]); // shouldn't have it
            // resolved yet
            var isEvaluated = evalIndexSet.has(index);
            // TODO: This code suggests that an ObjectMirror and Stutus are the
            //       same.  Resolve this.
            that.resolvedVariableTable[index] = that.resolveMirror_(that.rawVariableTable[index], isEvaluated);
            index++;
        }
        // If we filled up the buffer already, we need to trim the remainder
        if (index < that.rawVariableTable.length) {
            that.trimVariableTable_(index, frames);
        }
        return {
            // TODO (fgao): Add path attribute to avoid explicit cast to
            // stackdriver.SourceLocation once breakpoint is passed in this class.
            id: 'dummy-id',
            location: { line: this.state.frame(0).sourceLine() + 1 },
            stackFrames: frames,
            variableTable: that.resolvedVariableTable,
            evaluatedExpressions: that.evaluatedExpressions
        };
    };
    /**
     * Limits the size of the variable table to `fromIndex` elements. It marks
     * all variables with entries beyond `fromIndex` with a message indicating
     * that the table filled.
     *
     * @param {Number} fromIndex The desired size of the variable table.
     * @param {Object} frames Frames associated with the current execution
     *                        environment.
     */
    StateResolver.prototype.trimVariableTable_ = function (fromIndex, frames) {
        this.resolvedVariableTable.splice(fromIndex); // remove the remaining entries
        var that = this;
        var processBufferFull = function (variables) {
            variables.forEach(function (variable) {
                if (variable.varTableIndex && variable.varTableIndex >= fromIndex) {
                    // make it point to the sentinel 'buffer full' value
                    variable.varTableIndex = BUFFER_FULL_MESSAGE_INDEX;
                    variable.status = that.messageTable[BUFFER_FULL_MESSAGE_INDEX].status;
                }
                if (variable.members) {
                    processBufferFull(variable.members);
                }
            });
        };
        frames.forEach(function (frame) {
            processBufferFull(frame.arguments);
            processBufferFull(frame.locals);
        });
        processBufferFull(this.evaluatedExpressions);
        processBufferFull(this.resolvedVariableTable);
    };
    StateResolver.prototype.resolveFrames_ = function () {
        var frames = [];
        var frameCount = Math.min(this.state.frameCount(), this.config.capture.maxFrames);
        for (var i = 0; i < frameCount; i++) {
            var frame = this.state.frame(i);
            if (this.shouldFrameBeResolved_(frame)) {
                frames.push(this.resolveFrame_(frame, (i < this.config.capture.maxExpandFrames)));
            }
        }
        return frames;
    };
    StateResolver.prototype.shouldFrameBeResolved_ = function (frame) {
        // Only capture data from the frames for which we can link the data back
        // to the source files.
        var fullPath = this.resolveFullPath_(frame);
        if (!this.isPathInCurrentWorkingDirectory_(fullPath)) {
            return false;
        }
        var relativePath = this.resolveRelativePath_(frame);
        if (!this.config.capture.includeNodeModules &&
            this.isPathInNodeModulesDirectory_(relativePath)) {
            return false;
        }
        return true;
    };
    StateResolver.prototype.resolveFullPath_ = function (frame) {
        var func = frame.func();
        if (!func.resolved()) {
            return '';
        }
        var script = func.script();
        if (!script) {
            return '';
        }
        return script.name();
    };
    StateResolver.prototype.resolveRelativePath_ = function (frame) {
        var fullPath = this.resolveFullPath_(frame);
        return this.stripCurrentWorkingDirectory_(fullPath);
    };
    StateResolver.prototype.stripCurrentWorkingDirectory_ = function (path) {
        // Strip 1 extra character to remove the slash.
        return path.substr((this.config.workingDirectory).length + 1);
    };
    StateResolver.prototype.isPathInCurrentWorkingDirectory_ = function (path) {
        // return true;
        return path.indexOf(this.config.workingDirectory) === 0;
    };
    StateResolver.prototype.isPathInNodeModulesDirectory_ = function (path) {
        return path.indexOf('node_modules') === 0;
    };
    StateResolver.prototype.resolveFrame_ = function (frame, underFrameCap) {
        var args = [];
        // TODO: `locals` should be of type v8.ScopeMirror[]
        //       Resolve conflicts so that it can be specified of that type.
        var locals = [];
        // Locals and arguments are safe to collect even when
        // `config.allowExpressions=false` since we properly avoid inspecting
        // interceptors and getters by default.
        if (!underFrameCap) {
            args.push({
                name: 'arguments_not_available',
                varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX
            });
            locals.push({
                name: 'locals_not_available',
                varTableIndex: ARG_LOCAL_LIMIT_MESSAGE_INDEX
            });
        }
        else {
            // We will use the values aggregated from the ScopeMirror traversal stored
            // in locals which will include any applicable arguments from the
            // invocation.
            locals = this.resolveLocalsList_(frame);
            if (isEmpty(locals)) {
                locals = [];
            }
        }
        return {
            function: this.resolveFunctionName_(frame.func()),
            location: this.resolveLocation_(frame),
            arguments: args,
            locals: locals
        };
    };
    StateResolver.prototype.resolveFunctionName_ = function (func) {
        if (!func || !func.isFunction()) {
            return '';
        }
        return func.name() || func.inferredName() || '(anonymous function)';
    };
    StateResolver.prototype.resolveLocation_ = function (frame) {
        return {
            path: this.resolveRelativePath_(frame),
            // V8 uses 0-based line numbers but Debuglet API uses 1-based numbers.
            line: frame.sourceLine() + 1
        };
    };
    /**
     * Iterates and returns variable information for all scopes (excluding global)
     * in a given frame. FrameMirrors should return their scope object list with
     * most deeply nested scope first so variables initially encountered will take
     * precedence over subsequent instance with the same name - this is tracked in
     * the usedNames map. The argument list given to this function may be
     * manipulated if variables with a deeper scope occur which have the same
     * name.
     * @function resolveLocalsList_
     * @memberof StateResolver
     * @param {FrameMirror} frame - A instance of FrameMirror
     * @param {Array<Object>} args - An array of objects representing any function
     *  arguments the frame may list
     * @returns {Array<Object>} - returns an array containing data about selected
     *  variables
     */
    StateResolver.prototype.resolveLocalsList_ = function (frame) {
        var self = this;
        var usedNames = {};
        var makeMirror = this.ctx.MakeMirror;
        var allScopes = frame.allScopes();
        var count = allScopes.length;
        // There will always be at least 3 scopes.
        // For top-level breakpoints: [local, script, global]
        // Other: [..., closure (module IIFE), script, global]
        assert.ok(count >= 3);
        assert.strictEqual(allScopes[count - 1].scopeType(), ScopeType.Global);
        assert.strictEqual(allScopes[count - 2].scopeType(), ScopeType.Script);
        // We find the top-level (module global) variable pollute the local
        // variables we omit them by default, unless the breakpoint itself is
        // top-level. The last two scopes are always omitted.
        var scopes;
        if (allScopes[count - 3].scopeType() === ScopeType.Closure) {
            scopes = allScopes.slice(0, -3);
        }
        else {
            assert.ok(allScopes[count - 3].scopeType() === ScopeType.Local);
            scopes = allScopes.slice(0, -2);
        }
        var fromScopes = scopes.map(function (scope) {
            return transform(
            // TODO: Update this so that `locals` is not of type `any[]`.
            scope.details().object(), function (locals, value, name) {
                var trg = makeMirror(value);
                if (!usedNames[name]) {
                    // It's a valid variable that belongs in the locals list
                    // and wasn't discovered at a lower-scope
                    usedNames[name] = true;
                    // TODO: Determine how to not have an explicit down cast to
                    // ValueMirror
                    locals.push(self.resolveVariable_(name, trg, false));
                } // otherwise another same-named variable occured at a
                // lower scope
                return locals;
            }, []);
        });
        function resolveFromReceiver() {
            // The frame receiver is the 'this' context that is present during
            // invocation. Check to see whether a receiver context is substantive,
            // (invocations may be bound to null) if so: store in the locals list
            // under the name 'context' which is used by the Chrome DevTools.
            var ctx = frame.details().receiver();
            if (ctx) {
                // TODO: Determine how to not have an explicit down cast to
                // ValueMirror
                return [self.resolveVariable_('context', makeMirror(ctx), false)];
            }
            return [];
        }
        return flatten(fromScopes).concat(resolveFromReceiver());
    };
    /**
     * Computes a text representation of the provided value based on its type.
     * If the value is a recursive data type, it will be represented as an index
     * into the variable table.
     *
     * @param {String} name The name of the variable.
     * @param {Object} value A v8 debugger representation of a variable value.
     * @param {boolean} isEvaluated Specifies if the variable is from a watched
     *                              expression.
     */
    StateResolver.prototype.resolveVariable_ = function (name, value, isEvaluated) {
        var size = name.length;
        var data = { name: name };
        if (value.isPrimitive() || value.isRegExp()) {
            // primitives: undefined, null, boolean, number, string, symbol
            data.value = value.toText();
            var maxLength = this.config.capture.maxStringLength;
            if (!isEvaluated && maxLength && maxLength < data.value.length) {
                data.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Only first `config.capture.maxStringLength=' +
                    this.config.capture.maxStringLength +
                    '` chars were captured for string of length ' +
                    data.value.length +
                    '. Use in an expression to see the full string.', false);
                data.value = data.value.substring(0, maxLength) + '...';
            }
        }
        else if (value.isFunction()) {
            // TODO: Determine how to resolve this so that a ValueMirror doesn't need
            //       to be cast to a FunctionMirror.
            data.value = 'function ' +
                this.resolveFunctionName_(value) + '()';
        }
        else if (value.isObject()) {
            data.varTableIndex = this.getVariableIndex_(value);
        }
        else {
            // PropertyMirror, InternalPropertyMirror, FrameMirror, ScriptMirror
            data.value = 'unknown mirror type';
        }
        if (data.value) {
            size += data.value.length;
        }
        else {
            size += 8; // fudge-it
        }
        this.totalSize += size;
        return data;
    };
    StateResolver.prototype.getVariableIndex_ = function (value) {
        var idx = this.rawVariableTable.indexOf(value);
        if (idx === -1) {
            idx = this.storeObjectToVariableTable_(value);
        }
        return idx;
    };
    StateResolver.prototype.storeObjectToVariableTable_ = function (obj) {
        var idx = this.rawVariableTable.length;
        this.rawVariableTable[idx] = obj;
        return idx;
    };
    /**
     * Responsible for recursively resolving the properties on a
     * provided object mirror.
     */
    StateResolver.prototype.resolveMirror_ = function (mirror, isEvaluated) {
        var properties = mirror.properties();
        var maxProps = this.config.capture.maxProperties;
        var truncate = maxProps && properties.length > maxProps;
        if (!isEvaluated && truncate) {
            properties = properties.slice(0, maxProps);
        }
        // TODO: It looks like `members` should be of type stackdriver.Variable[]
        //       but is missing fields.  Determine if those fields are required or
        //       if the type should not be stackdriver.Variable[]
        var members = properties.map(this.resolveMirrorProperty_.bind(this, isEvaluated));
        if (!isEvaluated && truncate) {
            // TDOO: Determine how to remove this explicit cast
            members.push({
                name: 'Only first `config.capture.maxProperties=' +
                    this.config.capture.maxProperties +
                    '` properties were captured. Use in an expression' +
                    ' to see all properties.'
            });
        }
        return { value: mirror.toText(), members: members };
    };
    StateResolver.prototype.resolveMirrorProperty_ = function (isEvaluated, property) {
        var name = String(property.name());
        // Array length must be special cased as it is a native property that
        // we know to be safe to evaluate which is not generally true.
        var isArrayLen = property.mirror_.isArray() && name === 'length';
        if (property.isNative() && !isArrayLen) {
            return { name: name, varTableIndex: NATIVE_PROPERTY_MESSAGE_INDEX };
        }
        if (property.hasGetter()) {
            return { name: name, varTableIndex: GETTER_MESSAGE_INDEX };
        }
        return this.resolveVariable_(name, property.value(), isEvaluated);
    };
    return StateResolver;
}());
// This function is used by unit tests to make sure assertions are enabled.
function testAssert() {
    assert.equal(0, 1);
}
exports.testAssert = testAssert;
/**
 * Captures the stack and current execution state.
 *
 * @return an object with stackFrames, variableTable, and
 *         evaluatedExpressions fields
 */
function capture(execState, expressions, config, v8debug) {
    return (new StateResolver(execState, expressions, config, v8debug))
        .capture_();
}
exports.capture = capture;
//# sourceMappingURL=legacy-state.js.map