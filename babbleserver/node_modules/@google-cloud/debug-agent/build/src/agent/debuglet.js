"use strict";
/**
 * Copyright 2014 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var common = require('@google-cloud/common');
var crypto = require("crypto");
var events_1 = require("events");
var extend = require("extend");
var fs = require("fs");
var metadata = require("gcp-metadata");
var _ = require("lodash");
var path = require("path");
var util = require("util");
var utils = require("./util/utils");
var controller_1 = require("./controller");
var debuggee_1 = require("../debuggee");
var status_message_1 = require("../client/stackdriver/status-message");
var config_1 = require("./config");
var scanner = require("./io/scanner");
var SourceMapper = require("./io/sourcemapper");
var debugapi = require("./v8/debugapi");
var assert = require("assert");
var promisify = require('util.promisify');
var ALLOW_EXPRESSIONS_MESSAGE = 'Expressions and conditions are not allowed' +
    ' by default. Please set the allowExpressions configuration option to true.' +
    ' See the debug agent documentation at https://goo.gl/ShSm6r.';
var NODE_VERSION_MESSAGE = 'Node.js version not supported. Node.js 5.2.0 and ' +
    ' versions older than 0.12 are not supported.';
var BREAKPOINT_ACTION_MESSAGE = 'The only currently supported breakpoint actions' +
    ' are CAPTURE and LOG.';
// PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS is a heuristic duration that we set
// to force the debug agent to return a new promise for isReady. The value is
// the average of Stackdriver debugger hanging get duration (40s) and TCP
// time-out on GCF (540s).
var PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS = (40 + 540) / 2 * 1000;
/**
 * Formats a breakpoint object prefixed with a provided message as a string
 * intended for logging.
 * @param {string} msg The message that prefixes the formatted breakpoint.
 * @param {Breakpoint} breakpoint The breakpoint to format.
 * @return {string} A formatted string.
 */
var formatBreakpoint = function (msg, breakpoint) {
    var text = msg +
        util.format('breakpoint id: %s,\n\tlocation: %s', breakpoint.id, util.inspect(breakpoint.location));
    if (breakpoint.createdTime) {
        var unixTime = Number(breakpoint.createdTime.seconds);
        var date = new Date(unixTime * 1000); // to milliseconds.
        text += '\n\tcreatedTime: ' + date.toString();
    }
    if (breakpoint.condition) {
        text += '\n\tcondition: ' + util.inspect(breakpoint.condition);
    }
    if (breakpoint.expressions) {
        text += '\n\texpressions: ' + util.inspect(breakpoint.expressions);
    }
    return text;
};
/**
 * Formats a map of breakpoint objects prefixed with a provided message as a
 * string intended for logging.
 * @param {string} msg The message that prefixes the formatted breakpoint.
 * @param {Object.<string, Breakpoint>} breakpoints A map of breakpoints.
 * @return {string} A formatted string.
 */
var formatBreakpoints = function (msg, breakpoints) {
    return msg +
        Object.keys(breakpoints)
            .map(function (b) {
            return formatBreakpoint('', breakpoints[b]);
        })
            .join('\n');
};
/**
 * CachedPromise stores a promise. This promise can be resolved by calling
 * function resolve() and can only be resolved once.
 */
var CachedPromise = /** @class */ (function () {
    function CachedPromise() {
        var _this = this;
        this.promiseResolve = null;
        this.promise = new Promise(function (resolve) {
            _this.promiseResolve = resolve;
        });
    }
    CachedPromise.prototype.get = function () {
        return this.promise;
    };
    CachedPromise.prototype.resolve = function () {
        // Each promise can be resolved only once.
        if (this.promiseResolve) {
            this.promiseResolve();
            this.promiseResolve = null;
        }
    };
    return CachedPromise;
}());
exports.CachedPromise = CachedPromise;
/**
 * IsReadyManager is a wrapper class to use debuglet.isReady().
 */
var IsReadyImpl = /** @class */ (function () {
    function IsReadyImpl(debuglet) {
        this.debuglet = debuglet;
    }
    IsReadyImpl.prototype.isReady = function () {
        return this.debuglet.isReady();
    };
    return IsReadyImpl;
}());
var Debuglet = /** @class */ (function (_super) {
    __extends(Debuglet, _super);
    /**
     * @param {Debug} debug - A Debug instance.
     * @param {object=} config - The option parameters for the Debuglet.
     * @event 'started' once the startup tasks are completed. Only called once.
     * @event 'stopped' if the agent stops due to a fatal error after starting.
     * Only called once.
     * @event 'registered' once successfully registered to the debug api. May be
     *     emitted multiple times.
     * @event 'remotelyDisabled' if the debuggee is disabled by the server. May be
     *    called multiple times.
     * @constructor
     */
    function Debuglet(debug, config) {
        var _this = _super.call(this) || this;
        _this.isReadyManager = new IsReadyImpl(_this);
        /** @private {object} */
        _this.config = Debuglet.normalizeConfig_(config);
        /** @private {Debug} */
        _this.debug = debug;
        /**
         * @private {object} V8 Debug API. This can be null if the Node.js version
         *     is out of date.
         */
        _this.v8debug = null;
        /** @private {boolean} */
        _this.running = false;
        /** @private {string} */
        _this.project = null;
        /** @private {boolean} */
        _this.fetcherActive = false;
        /** @private {common.logger} */
        _this.logger = new common.logger({
            level: common.logger.LEVELS[_this.config.logLevel],
            tag: _this.debug.packageInfo.name
        });
        /** @private {DebugletApi} */
        _this.controller = new controller_1.Controller(_this.debug);
        /** @private {Debuggee} */
        _this.debuggee = null;
        /** @private {Object.<string, Breakpoint>} */
        _this.activeBreakpointMap = {};
        /** @private {Object.<string, Boolean>} */
        _this.completedBreakpointMap = {};
        _this.breakpointFetched = null;
        _this.breakpointFetchedTimestamp = -Infinity;
        _this.debuggeeRegistered = new CachedPromise();
        return _this;
    }
    Debuglet.normalizeConfig_ = function (config) {
        var envConfig = {
            logLevel: process.env.GCLOUD_DEBUG_LOGLEVEL,
            serviceContext: {
                service: process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME,
                version: process.env.GAE_VERSION || process.env.GAE_MODULE_VERSION,
                minorVersion_: process.env.GAE_DEPLOYMENT_ID || process.env.GAE_MINOR_VERSION
            }
        };
        if (process.env.FUNCTION_NAME) {
            envConfig.serviceContext.service = process.env.FUNCTION_NAME;
            envConfig.serviceContext.version = 'unversioned';
        }
        return extend(true, {}, config_1.defaultConfig, config, envConfig);
    };
    Debuglet.findFiles = function (shouldHash, baseDir) {
        return __awaiter(this, void 0, void 0, function () {
            var fileStats, jsStats, mapFiles, errors;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, scanner.scan(shouldHash, baseDir, /.js$|.js.map$/)];
                    case 1:
                        fileStats = _a.sent();
                        jsStats = fileStats.selectStats(/.js$/);
                        mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());
                        errors = fileStats.errors();
                        return [2 /*return*/, { jsStats: jsStats, mapFiles: mapFiles, errors: errors, hash: fileStats.hash }];
                }
            });
        });
    };
    /**
     * Starts the Debuglet. It is important that this is as quick as possible
     * as it is on the critical path of application startup.
     * @private
     */
    Debuglet.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var that, stat, err_1, workingDir, message, id, findResults, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        that = this;
                        stat = promisify(fs.stat);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, stat(path.join(that.config.workingDirectory, 'package.json'))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        that.logger.error('No package.json located in working directory.');
                        that.emit('initError', new Error('No package.json found.'));
                        return [2 /*return*/];
                    case 4:
                        workingDir = that.config.workingDirectory;
                        // Don't continue if the working directory is a root directory
                        // unless the user wants to force using the root directory
                        if (!that.config.allowRootAsWorkingDirectory &&
                            path.join(workingDir, '..') === workingDir) {
                            message = 'The working directory is a root directory. Disabling ' +
                                'to avoid a scan of the entire filesystem for JavaScript files. ' +
                                'Use config \allowRootAsWorkingDirectory` if you really want to ' +
                                'do this.';
                            that.logger.error(message);
                            that.emit('initError', new Error(message));
                            return [2 /*return*/];
                        }
                        if (process.env.GAE_MINOR_VERSION) {
                            id = 'GAE-' + process.env.GAE_MINOR_VERSION;
                        }
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, Debuglet.findFiles(!id, that.config.workingDirectory)];
                    case 6:
                        findResults = _a.sent();
                        findResults.errors.forEach(that.logger.warn);
                        return [3 /*break*/, 8];
                    case 7:
                        err_2 = _a.sent();
                        that.logger.error('Error scanning the filesystem.', err_2);
                        that.emit('initError', err_2);
                        return [2 /*return*/];
                    case 8:
                        SourceMapper.create(findResults.mapFiles, function (err3, sourcemapper) { return __awaiter(_this, void 0, void 0, function () {
                            var mapper, onGCP, project, err_3, clusterName, err_4;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (err3) {
                                            that.logger.error('Error processing the sourcemaps.', err3);
                                            that.emit('initError', err3);
                                            return [2 /*return*/];
                                        }
                                        mapper = sourcemapper;
                                        that.v8debug = debugapi.create(that.logger, that.config, findResults.jsStats, mapper);
                                        id = id || findResults.hash;
                                        that.logger.info('Unique ID for this Application: ' + id);
                                        return [4 /*yield*/, Debuglet.runningOnGCP()];
                                    case 1:
                                        onGCP = _a.sent();
                                        _a.label = 2;
                                    case 2:
                                        _a.trys.push([2, 4, , 5]);
                                        return [4 /*yield*/, Debuglet.getProjectId(that.debug.options)];
                                    case 3:
                                        project = _a.sent();
                                        return [3 /*break*/, 5];
                                    case 4:
                                        err_3 = _a.sent();
                                        that.logger.error('The project ID could not be determined: ' + err_3.message);
                                        that.emit('initError', err_3);
                                        return [2 /*return*/];
                                    case 5:
                                        if (!(onGCP &&
                                            (!that.config.serviceContext ||
                                                !that.config.serviceContext.service))) return [3 /*break*/, 9];
                                        _a.label = 6;
                                    case 6:
                                        _a.trys.push([6, 8, , 9]);
                                        return [4 /*yield*/, Debuglet.getClusterNameFromMetadata()];
                                    case 7:
                                        clusterName = _a.sent();
                                        that.config.serviceContext = {
                                            service: clusterName,
                                            version: 'unversioned',
                                            minorVersion_: undefined
                                        };
                                        return [3 /*break*/, 9];
                                    case 8:
                                        err_4 = _a.sent();
                                        return [3 /*break*/, 9];
                                    case 9:
                                        that.getSourceContext_(function (err5, sourceContext) {
                                            if (err5) {
                                                that.logger.warn('Unable to discover source context', err5);
                                                // This is ignorable.
                                            }
                                            if (utils.satisfies(process.version, '5.2 || <4')) {
                                                // Using an unsupported version. We report an error
                                                // message about the Node.js version, but we keep on
                                                // running. The idea is that the user may miss the error
                                                // message on the console. This way we can report the
                                                // error when the user tries to set a breakpoint.
                                                that.logger.error(NODE_VERSION_MESSAGE);
                                            }
                                            // We can register as a debuggee now.
                                            that.logger.debug('Starting debuggee, project', project);
                                            that.running = true;
                                            // TODO: Address the case where `project` is `undefined`.
                                            that.project = project;
                                            that.debuggee = Debuglet.createDebuggee(
                                            // TODO: Address the case when `id` is `undefined`.
                                            project, id, that.config.serviceContext, sourceContext, onGCP, that.debug.packageInfo, that.config.description, undefined);
                                            that.scheduleRegistration_(0 /* immediately */);
                                            that.emit('started');
                                        });
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * isReady returns a promise that only resolved if the last breakpoint update
     * happend within a duration (PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS). This
     * feature is mainly used in Google Cloud Function (GCF), as it is a
     * serverless environment and we wanted to make sure debug agent always
     * captures the snapshots.
     */
    Debuglet.prototype.isReady = function () {
        var _this = this;
        if (Date.now() < this.breakpointFetchedTimestamp +
            PROMISE_RESOLVE_CUT_OFF_IN_MILLISECONDS) {
            return Promise.resolve();
        }
        else {
            if (this.breakpointFetched)
                return this.breakpointFetched.get();
            this.breakpointFetched = new CachedPromise();
            this.debuggeeRegistered.get().then(function () {
                _this.scheduleBreakpointFetch_(0 /*immediately*/, true /*only fetch once*/);
            });
            return this.breakpointFetched.get();
        }
    };
    /**
     * @private
     */
    // TODO: Determine the type of sourceContext
    Debuglet.createDebuggee = function (projectId, uid, serviceContext, sourceContext, onGCP, packageInfo, description, errorMessage) {
        var cwd = process.cwd();
        var mainScript = path.relative(cwd, process.argv[1]);
        var version = 'google.com/node-' + (onGCP ? 'gcp' : 'standalone') + '/v' +
            packageInfo.version;
        var desc = process.title + ' ' + mainScript;
        var labels = {
            'main script': mainScript,
            'process.title': process.title,
            'node version': process.versions.node,
            'V8 version': process.versions.v8,
            'agent.name': packageInfo.name,
            'agent.version': packageInfo.version,
            'projectid': projectId
        };
        if (serviceContext) {
            if (_.isString(serviceContext.service) &&
                serviceContext.service !== 'default') {
                // As per app-engine-ids, the module label is not reported
                // when it happens to be 'default'.
                labels.module = serviceContext.service;
                desc += ' module:' + serviceContext.service;
            }
            if (_.isString(serviceContext.version)) {
                labels.version = serviceContext.version;
                desc += ' version:' + serviceContext.version;
            }
            if (_.isString(serviceContext.minorVersion_)) {
                //          v--- intentional lowercase
                labels.minorversion = serviceContext.minorVersion_;
            }
        }
        if (!description && process.env.FUNCTION_NAME) {
            description = 'Function: ' + process.env.FUNCTION_NAME;
        }
        if (description) {
            desc += ' description:' + description;
        }
        var uniquifier = Debuglet._createUniquifier(desc, version, uid, sourceContext, labels);
        var statusMessage = errorMessage ?
            new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, errorMessage, true) :
            undefined;
        var properties = {
            project: projectId,
            uniquifier: uniquifier,
            description: desc,
            agentVersion: version,
            labels: labels,
            statusMessage: statusMessage,
            sourceContexts: [sourceContext],
            packageInfo: packageInfo
        };
        return new debuggee_1.Debuggee(properties);
    };
    Debuglet.getProjectId = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var project, _a, msg;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = options.projectId || process.env.GCLOUD_PROJECT;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getProjectIdFromMetadata()];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        project = _a;
                        if (!project) {
                            msg = 'Unable to discover projectId. Please provide the ' +
                                'projectId to be able to use the Debug agent';
                            throw new Error(msg);
                        }
                        return [2 /*return*/, project];
                }
            });
        });
    };
    Debuglet.runningOnGCP = function () {
        return metadata.isAvailable();
    };
    Debuglet.getProjectIdFromMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, metadata.project('project-id')];
                    case 1: return [2 /*return*/, (_a.sent()).data];
                }
            });
        });
    };
    Debuglet.getClusterNameFromMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, metadata.instance('attributes/cluster-name')];
                    case 1: return [2 /*return*/, (_a.sent()).data];
                }
            });
        });
    };
    Debuglet.prototype.getSourceContext_ = function (callback) {
        fs.readFile('source-context.json', 'utf8', function (err, data) {
            var sourceContext;
            if (!err) {
                try {
                    sourceContext = JSON.parse(data);
                }
                catch (e) {
                    // TODO: Fix casting `err` from an ErrnoException to a string
                    err = 'Malformed source-context.json file: ' + e;
                }
            }
            // We keep on going even if there are errors.
            return callback(err, sourceContext);
        });
    };
    /**
     * @param {number} seconds
     * @private
     */
    Debuglet.prototype.scheduleRegistration_ = function (seconds) {
        var that = this;
        function onError(err) {
            that.logger.error('Failed to re-register debuggee ' + that.project + ': ' + err);
            that.scheduleRegistration_(Math.min((seconds + 1) * 2, that.config.internal.maxRegistrationRetryDelay));
        }
        setTimeout(function () {
            if (!that.running) {
                onError(new Error('Debuglet not running'));
                return;
            }
            // TODO: Handle the case when `that.debuggee` is null.
            that.controller.register(that.debuggee, function (err, result) {
                if (err) {
                    onError(err);
                    return;
                }
                // TODO: It appears that the Debuggee class never has an
                // `isDisabled`
                //       field set.  Determine if this is a bug or if the following
                //       code is not needed.
                // TODO: Handle the case when `result` is undefined.
                if (result.debuggee.isDisabled) {
                    // Server has disabled this debuggee / debug agent.
                    onError(new Error('Disabled by the server'));
                    that.emit('remotelyDisabled');
                    return;
                }
                // TODO: Handle the case when `result` is undefined.
                that.logger.info('Registered as debuggee:', result.debuggee.id);
                // TODO: Handle the case when `that.debuggee` is null.
                // TODO: Handle the case when `result` is undefined.
                that.debuggee.id =
                    result.debuggee.id;
                // TODO: Handle the case when `result` is undefined.
                that.emit('registered', result.debuggee.id);
                that.debuggeeRegistered.resolve();
                if (!that.fetcherActive) {
                    that.scheduleBreakpointFetch_(0, false);
                }
            });
        }, seconds * 1000).unref();
    };
    /**
     * @param {number} seconds
     * @param {boolean} once
     * @private
     */
    Debuglet.prototype.scheduleBreakpointFetch_ = function (seconds, once) {
        var that = this;
        if (!once) {
            that.fetcherActive = true;
        }
        setTimeout(function () {
            if (!that.running) {
                return;
            }
            if (!once) {
                assert(that.fetcherActive);
            }
            that.logger.info('Fetching breakpoints');
            // TODO: Address the case when `that.debuggee` is `null`.
            that.controller.listBreakpoints(that.debuggee, function (err, response, body) {
                if (err) {
                    that.logger.error('Unable to fetch breakpoints – stopping fetcher', err);
                    that.fetcherActive = false;
                    // We back-off from fetching breakpoints, and try to register
                    // again after a while. Successful registration will restart the
                    // breakpoint fetcher.
                    that.updatePromise();
                    that.scheduleRegistration_(that.config.internal.registerDelayOnFetcherErrorSec);
                    return;
                }
                // TODO: Address the case where `response` is `undefined`.
                switch (response.statusCode) {
                    case 404:
                        // Registration expired. Deactivate the fetcher and queue
                        // re-registration, which will re-active breakpoint fetching.
                        that.logger.info('\t404 Registration expired.');
                        that.fetcherActive = false;
                        that.updatePromise();
                        that.scheduleRegistration_(0 /*immediately*/);
                        return;
                    default:
                        // TODO: Address the case where `response` is `undefined`.
                        that.logger.info('\t' + response.statusCode +
                            ' completed.');
                        if (!body) {
                            that.logger.error('\tinvalid list response: empty body');
                            that.scheduleBreakpointFetch_(that.config.breakpointUpdateIntervalSec, once);
                            return;
                        }
                        if (body.waitExpired) {
                            that.logger.info('\tLong poll completed.');
                            that.scheduleBreakpointFetch_(0 /*immediately*/, once);
                            return;
                        }
                        var bps = (body.breakpoints ||
                            []).filter(function (bp) {
                            var action = bp.action || 'CAPTURE';
                            if (action !== 'CAPTURE' && action !== 'LOG') {
                                that.logger.warn('Found breakpoint with invalid action:', action);
                                bp.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, BREAKPOINT_ACTION_MESSAGE, true);
                                that.rejectBreakpoint_(bp);
                                return false;
                            }
                            return true;
                        });
                        that.updateActiveBreakpoints_(bps);
                        if (Object.keys(that.activeBreakpointMap).length) {
                            that.logger.info(formatBreakpoints('Active Breakpoints: ', that.activeBreakpointMap));
                        }
                        that.breakpointFetchedTimestamp = Date.now();
                        if (once) {
                            if (that.breakpointFetched) {
                                that.breakpointFetched.resolve();
                                that.breakpointFetched = null;
                            }
                        }
                        else {
                            that.scheduleBreakpointFetch_(that.config.breakpointUpdateIntervalSec, once);
                        }
                        return;
                }
            });
        }, seconds * 1000).unref();
    };
    /**
     * updatePromise_ is called when debuggee is expired. debuggeeRegistered
     * CachedPromise will be refreshed. Also, breakpointFetched CachedPromise will
     * be resolved so that uses (such as GCF users) will not hang forever to wait
     * non-fetchable breakpoints.
     */
    Debuglet.prototype.updatePromise = function () {
        this.debuggeeRegistered = new CachedPromise();
        if (this.breakpointFetched) {
            this.breakpointFetched.resolve();
            this.breakpointFetched = null;
        }
    };
    /**
     * Given a list of server breakpoints, update our internal list of breakpoints
     * @param {Array.<Breakpoint>} breakpoints
     * @private
     */
    Debuglet.prototype.updateActiveBreakpoints_ = function (breakpoints) {
        var that = this;
        var updatedBreakpointMap = this.convertBreakpointListToMap_(breakpoints);
        if (breakpoints.length) {
            that.logger.info(formatBreakpoints('Server breakpoints: ', updatedBreakpointMap));
        }
        breakpoints.forEach(function (breakpoint) {
            // TODO: Address the case when `breakpoint.id` is `undefined`.
            if (!that.completedBreakpointMap[breakpoint.id] &&
                !that.activeBreakpointMap[breakpoint.id]) {
                // New breakpoint
                that.addBreakpoint_(breakpoint, function (err) {
                    if (err) {
                        that.completeBreakpoint_(breakpoint);
                    }
                });
                // Schedule the expiry of server breakpoints.
                that.scheduleBreakpointExpiry_(breakpoint);
            }
        });
        // Remove completed breakpoints that the server no longer cares about.
        Debuglet.mapSubtract(this.completedBreakpointMap, updatedBreakpointMap)
            .forEach(function (breakpoint) {
            // TODO: FIXME: breakpoint is a boolean here that doesn't have an id
            //              field.  It is possible that breakpoint.id is always
            //              undefined!
            // TODO: Make sure the use of `that` here is correct.
            delete that
                .completedBreakpointMap[breakpoint.id];
        });
        // Remove active breakpoints that the server no longer care about.
        Debuglet.mapSubtract(this.activeBreakpointMap, updatedBreakpointMap)
            .forEach(this.removeBreakpoint_, this);
    };
    /**
     * Array of breakpints get converted to Map of breakpoints, indexed by id
     * @param {Array.<Breakpoint>} breakpointList
     * @return {Object.<string, Breakpoint>} A map of breakpoint IDs to breakpoints.
     * @private
     */
    Debuglet.prototype.convertBreakpointListToMap_ = function (breakpointList) {
        var map = {};
        breakpointList.forEach(function (breakpoint) {
            // TODO: Address the case when `breakpoint.id` is `undefined`.
            map[breakpoint.id] = breakpoint;
        });
        return map;
    };
    /**
     * @param {Breakpoint} breakpoint
     * @private
     */
    Debuglet.prototype.removeBreakpoint_ = function (breakpoint) {
        var _this = this;
        this.logger.info('\tdeleted breakpoint', breakpoint.id);
        // TODO: Address the case when `breakpoint.id` is `undefined`.
        delete this.activeBreakpointMap[breakpoint.id];
        if (this.v8debug) {
            this.v8debug.clear(breakpoint, function (err) {
                if (err)
                    _this.logger.error(err);
            });
        }
    };
    /**
     * @param {Breakpoint} breakpoint
     * @return {boolean} false on error
     * @private
     */
    Debuglet.prototype.addBreakpoint_ = function (breakpoint, cb) {
        var that = this;
        if (!that.config.allowExpressions &&
            (breakpoint.condition || breakpoint.expressions)) {
            that.logger.error(ALLOW_EXPRESSIONS_MESSAGE);
            breakpoint.status = new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, ALLOW_EXPRESSIONS_MESSAGE, true);
            setImmediate(function () {
                cb(ALLOW_EXPRESSIONS_MESSAGE);
            });
            return;
        }
        if (utils.satisfies(process.version, '5.2 || <4')) {
            var message_1 = NODE_VERSION_MESSAGE;
            that.logger.error(message_1);
            breakpoint.status =
                new status_message_1.StatusMessage(status_message_1.StatusMessage.UNSPECIFIED, message_1, true);
            setImmediate(function () {
                cb(message_1);
            });
            return;
        }
        // TODO: Address the case when `that.v8debug` is `null`.
        that.v8debug.set(breakpoint, function (err1) {
            if (err1) {
                cb(err1);
                return;
            }
            that.logger.info('\tsuccessfully added breakpoint  ' + breakpoint.id);
            // TODO: Address the case when `breakpoint.id` is `undefined`.
            that.activeBreakpointMap[breakpoint.id] = breakpoint;
            if (breakpoint.action === 'LOG') {
                // TODO: Address the case when `that.v8debug` is `null`.
                that.v8debug
                    .log(breakpoint, function (fmt, exprs) {
                    console.log('LOGPOINT:', Debuglet.format(fmt, exprs));
                }, function () {
                    // TODO: Address the case when `breakpoint.id` is `undefined`.
                    return that.completedBreakpointMap[breakpoint.id];
                });
            }
            else {
                // TODO: Address the case when `that.v8debug` is `null`.
                that.v8debug.wait(breakpoint, function (err2) {
                    if (err2) {
                        that.logger.error(err2);
                        cb(err2);
                        return;
                    }
                    that.logger.info('Breakpoint hit!: ' + breakpoint.id);
                    that.completeBreakpoint_(breakpoint);
                });
            }
        });
    };
    /**
     * Update the server that the breakpoint has been completed (captured, or
     * expired).
     * @param {Breakpoint} breakpoint
     * @private
     */
    Debuglet.prototype.completeBreakpoint_ = function (breakpoint) {
        var that = this;
        that.logger.info('\tupdating breakpoint data on server', breakpoint.id);
        that.controller.updateBreakpoint(
        // TODO: Address the case when `that.debuggee` is `null`.
        that.debuggee, breakpoint, function (err /*, body*/) {
            if (err) {
                that.logger.error('Unable to complete breakpoint on server', err);
            }
            else {
                // TODO: Address the case when `breakpoint.id` is `undefined`.
                that.completedBreakpointMap[breakpoint.id] = true;
                that.removeBreakpoint_(breakpoint);
            }
        });
    };
    /**
     * Update the server that the breakpoint cannot be handled.
     * @param {Breakpoint} breakpoint
     * @private
     */
    Debuglet.prototype.rejectBreakpoint_ = function (breakpoint) {
        var that = this;
        // TODO: Address the case when `that.debuggee` is `null`.
        that.controller.updateBreakpoint(that.debuggee, breakpoint, function (err /*, body*/) {
            if (err) {
                that.logger.error('Unable to complete breakpoint on server', err);
            }
        });
    };
    /**
     * This schedules a delayed operation that will delete the breakpoint from the
     * server after the expiry period.
     * FIXME: we should cancel the timer when the breakpoint completes. Otherwise
     * we hold onto the closure memory until the breapointExpirateion timeout.
     * @param {Breakpoint} breakpoint Server breakpoint object
     * @private
     */
    Debuglet.prototype.scheduleBreakpointExpiry_ = function (breakpoint) {
        var that = this;
        var now = Date.now() / 1000;
        var createdTime = breakpoint.createdTime ? Number(breakpoint.createdTime.seconds) : now;
        var expiryTime = createdTime + that.config.breakpointExpirationSec;
        setTimeout(function () {
            that.logger.info('Expiring breakpoint ' + breakpoint.id);
            breakpoint.status = {
                description: { format: 'The snapshot has expired' },
                isError: true,
                refersTo: status_message_1.StatusMessage.BREAKPOINT_AGE
            };
            that.completeBreakpoint_(breakpoint);
        }, (expiryTime - now) * 1000).unref();
    };
    /**
     * Stops the Debuglet. This is for testing purposes only. Stop should only be
     * called on a agent that has started (i.e. emitted the 'started' event).
     * Calling this while the agent is initializing may not necessarily stop all
     * pending operations.
     */
    Debuglet.prototype.stop = function () {
        assert.ok(this.running, 'stop can only be called on a running agent');
        this.logger.debug('Stopping Debuglet');
        this.running = false;
        this.emit('stopped');
    };
    /**
     * Performs a set subtract. Returns A - B given maps A, B.
     * @return {Array.<Breakpoint>} A array containing elements from A that are not
     *     in B.
     */
    // TODO: Determine if this can be generic
    // TODO: The code that uses this actually assumes the supplied arguments
    //       are objects and used as an associative array.  Determine what is
    //       correct (the code or the docs).
    // TODO: Fix the docs because the code actually assumes that the values
    //       of the keys in the supplied arguments have boolean values or
    //       Breakpoint values.
    Debuglet.mapSubtract = function (A, B) {
        var removed = [];
        for (var key in A) {
            if (!B[key]) {
                removed.push(A[key]);
            }
        }
        return removed;
    };
    /**
     * Formats the message base with placeholders `$0`, `$1`, etc
     * by substituting the provided expressions. If more expressions
     * are given than placeholders extra expressions are dropped.
     */
    Debuglet.format = function (base, exprs) {
        var tokens = Debuglet._tokenize(base, exprs.length);
        for (var i = 0; i < tokens.length; i++) {
            // TODO: Determine how to remove this explicit cast
            if (!tokens[i].v) {
                continue;
            }
            // TODO: Determine how to not have an explicit cast here
            if (tokens[i].v === '$$') {
                tokens[i] = '$';
                continue;
            }
            for (var j = 0; j < exprs.length; j++) {
                // TODO: Determine how to not have an explicit cast here
                if (tokens[i].v === '$' + j) {
                    tokens[i] = exprs[j];
                    break;
                }
            }
        }
        return tokens.join('');
    };
    Debuglet._tokenize = function (base, exprLength) {
        var acc = Debuglet._delimit(base, '$$');
        for (var i = exprLength - 1; i >= 0; i--) {
            var newAcc = [];
            for (var j = 0; j < acc.length; j++) {
                // TODO: Determine how to remove this explicit cast
                if (acc[j].v) {
                    newAcc.push(acc[j]);
                }
                else {
                    // TODO: Determine how to not have an explicit cast to string here
                    newAcc.push.apply(newAcc, Debuglet._delimit(acc[j], '$' + i));
                }
            }
            acc = newAcc;
        }
        return acc;
    };
    Debuglet._delimit = function (source, delim) {
        var pieces = source.split(delim);
        var dest = [];
        dest.push(pieces[0]);
        for (var i = 1; i < pieces.length; i++) {
            dest.push({ v: delim }, pieces[i]);
        }
        return dest;
    };
    Debuglet._createUniquifier = function (desc, version, uid, sourceContext, labels) {
        var uniquifier = desc + version + uid + JSON.stringify(sourceContext) +
            JSON.stringify(labels);
        return crypto.createHash('sha1').update(uniquifier).digest('hex');
    };
    return Debuglet;
}(events_1.EventEmitter));
exports.Debuglet = Debuglet;
//# sourceMappingURL=debuglet.js.map