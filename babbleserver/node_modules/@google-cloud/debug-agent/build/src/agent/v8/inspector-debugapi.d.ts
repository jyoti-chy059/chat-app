import * as estree from 'estree';
import * as inspector from 'inspector';
import { Logger } from '../../types/common';
import * as stackdriver from '../../types/stackdriver';
import { ResolvedDebugAgentConfig } from '../config';
import { ScanStats } from '../io/scanner';
import { SourceMapper } from '../io/sourcemapper';
import * as utils from '../util/utils';
import * as debugapi from './debugapi';
import { V8Inspector } from './v8inspector';
export declare class BreakpointData {
    id: inspector.Debugger.BreakpointId;
    apiBreakpoint: stackdriver.Breakpoint;
    parsedCondition: estree.Node;
    locationStr: string;
    compile: null | ((src: string) => string);
    constructor(id: inspector.Debugger.BreakpointId, apiBreakpoint: stackdriver.Breakpoint, parsedCondition: estree.Node, locationStr: string, compile: null | ((src: string) => string));
}
export declare class InspectorDebugApi implements debugapi.DebugApi {
    logger: Logger;
    config: ResolvedDebugAgentConfig;
    fileStats: ScanStats;
    breakpoints: {
        [id: string]: BreakpointData;
    };
    sourcemapper: SourceMapper;
    session: inspector.Session;
    listeners: {
        [id: string]: utils.Listener;
    };
    scriptMapper: {
        [id: string]: {
            url: string;
        };
    };
    locationMapper: {
        [id: string]: stackdriver.BreakpointId[];
    };
    breakpointMapper: {
        [id: string]: stackdriver.BreakpointId[];
    };
    numBreakpoints: number;
    v8Inspector: V8Inspector;
    constructor(logger: Logger, config: ResolvedDebugAgentConfig, jsFiles: ScanStats, sourcemapper: SourceMapper);
    set(breakpoint: stackdriver.Breakpoint, cb: (err: Error | null) => void): void;
    clear(breakpoint: stackdriver.Breakpoint, cb: (err: Error | null) => void): void;
    wait(breakpoint: stackdriver.Breakpoint, callback: (err?: Error) => void): void;
    log(breakpoint: stackdriver.Breakpoint, print: (format: string, exps: string[]) => void, shouldStop: () => boolean): void;
    disconnect(): void;
    numBreakpoints_(): number;
    numListeners_(): number;
    /**
     * Internal breakpoint set function. At this point we have looked up source
     * maps (if necessary), and scriptPath happens to be a JavaScript path.
     *
     * @param {!Breakpoint} breakpoint Debug API Breakpoint object
     * @param {!MapInfoOutput|null} mapInfo A map that has a "file" attribute for
     *    the path of the output file associated with the given input file
     * @param {function(string)=} compile optional compile function that can be
     *    be used to compile source expressions to JavaScript
     * @param {function(?Error)} cb error-back style callback
     */
    private setInternal(breakpoint, mapInfo, compile, cb);
    private setAndStoreBreakpoint(breakpoint, line, column, matchingScript);
    private onBreakpointHit(breakpoint, callback, callFrames);
    private captureBreakpointData(breakpoint, callFrames);
    private handleDebugPausedEvent(params);
}
