"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var acorn = require("acorn");
var inspector = require("inspector");
var path = require("path");
var status_message_1 = require("../../client/stackdriver/status-message");
var state = require("../state/inspector-state");
var utils = require("../util/utils");
var debugapi = require("./debugapi");
var v8inspector_1 = require("./v8inspector");
var BreakpointData = /** @class */ (function () {
    function BreakpointData(id, apiBreakpoint, parsedCondition, locationStr, compile) {
        this.id = id;
        this.apiBreakpoint = apiBreakpoint;
        this.parsedCondition = parsedCondition;
        this.locationStr = locationStr;
        this.compile = compile;
    }
    return BreakpointData;
}());
exports.BreakpointData = BreakpointData;
var InspectorDebugApi = /** @class */ (function () {
    function InspectorDebugApi(logger, config, jsFiles, sourcemapper) {
        var _this = this;
        this.breakpoints = {};
        // TODO: listeners, scrpitmapper, location mapper and breakpointmapper can use
        // Map in the future after resolving Map.prototype.get(key) returns V or
        // undefined.
        this.listeners = {};
        // scriptmapper maps scriptId to actual script path.
        this.scriptMapper = {};
        // locationmapper maps location string to a list of stackdriver breakpoint id.
        this.locationMapper = {};
        // breakpointmapper maps v8/inspector breakpoint id to a list of
        // stackdriver breakpoint id.
        this.breakpointMapper = {};
        this.numBreakpoints = 0;
        this.logger = logger;
        this.config = config;
        this.fileStats = jsFiles;
        this.sourcemapper = sourcemapper;
        this.session = new inspector.Session();
        this.session.connect();
        this.session.on('Debugger.scriptParsed', function (script) {
            _this.scriptMapper[script.params.scriptId] = script.params;
        });
        this.session.post('Debugger.enable');
        this.session.post('Debugger.setBreakpointsActive', { active: true });
        this.session.on('Debugger.paused', function (message) {
            try {
                _this.handleDebugPausedEvent(message.params);
            }
            catch (error) {
                _this.logger.error(error);
            }
        });
        this.v8Inspector = new v8inspector_1.V8Inspector(this.session);
    }
    InspectorDebugApi.prototype.set = function (breakpoint, cb) {
        if (!breakpoint ||
            typeof breakpoint.id === 'undefined' || // 0 is a valid id
            !breakpoint.location || !breakpoint.location.path ||
            !breakpoint.location.line) {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.UNSPECIFIED, utils.messages.INVALID_BREAKPOINT);
        }
        var baseScriptPath = path.normalize(breakpoint.location.path);
        if (!this.sourcemapper.hasMappingInfo(baseScriptPath)) {
            if (!baseScriptPath.endsWith('js')) {
                return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.COULD_NOT_FIND_OUTPUT_FILE);
            }
            this.setInternal(breakpoint, null /* mapInfo */, null /* compile */, cb);
        }
        else {
            var line = breakpoint.location.line;
            var column = 0;
            var mapInfo = this.sourcemapper.mappingInfo(baseScriptPath, line, column);
            var compile = utils.getBreakpointCompiler(breakpoint);
            if (breakpoint.condition && compile) {
                try {
                    breakpoint.condition = compile(breakpoint.condition);
                }
                catch (e) {
                    this.logger.info('Unable to compile condition >> ' + breakpoint.condition + ' <<');
                    return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.ERROR_COMPILING_CONDITION);
                }
            }
            this.setInternal(breakpoint, mapInfo, compile, cb);
        }
    };
    InspectorDebugApi.prototype.clear = function (breakpoint, cb) {
        if (typeof breakpoint.id === 'undefined') {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);
        }
        var breakpointData = this.breakpoints[breakpoint.id];
        if (!breakpointData) {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.V8_BREAKPOINT_CLEAR_ERROR);
        }
        var locationStr = breakpointData.locationStr;
        var v8BreakpointId = breakpointData.id;
        // delete current breakpoint from locationmapper and breakpointmapper.
        utils.removeFirstOccurrenceInArray(this.locationMapper[locationStr], breakpoint.id);
        if (this.locationMapper[locationStr].length === 0) {
            delete this.locationMapper[locationStr];
        }
        utils.removeFirstOccurrenceInArray(this.breakpointMapper[v8BreakpointId], breakpoint.id);
        if (this.breakpointMapper[v8BreakpointId].length === 0) {
            delete this.breakpointMapper[v8BreakpointId];
        }
        var result = {};
        if (!this.breakpointMapper[breakpointData.id]) {
            // When breakpointmapper does not countain current v8/inspector breakpoint
            // id, we should remove this breakpoint from v8.
            result = this.v8Inspector.removeBreakpoint(breakpointData.id);
        }
        delete this.breakpoints[breakpoint.id];
        delete this.listeners[breakpoint.id];
        this.numBreakpoints--;
        setImmediate(function () {
            if (result.error) {
                cb(result.error);
            }
            cb(null);
        });
    };
    InspectorDebugApi.prototype.wait = function (breakpoint, callback) {
        var _this = this;
        // TODO: Address the case whree `breakpoint.id` is `null`.
        var listener = this.onBreakpointHit.bind(this, breakpoint, function (err) {
            _this.listeners[breakpoint.id].enabled = false;
            // This method is called from the debug event listener, which
            // swallows all exception. We defer the callback to make sure
            // the user errors aren't silenced.
            setImmediate(function () {
                callback(err);
            });
        });
        this.listeners[breakpoint.id] = { enabled: true, listener: listener };
    };
    InspectorDebugApi.prototype.log = function (breakpoint, print, shouldStop) {
        var _this = this;
        // TODO: Address the case whree `breakpoint.id` is `null`.
        var logsThisSecond = 0;
        var timesliceEnd = Date.now() + 1000;
        // TODO: Determine why the Error argument is not used.
        var listener = this.onBreakpointHit.bind(this, breakpoint, function (err) {
            var currTime = Date.now();
            if (currTime > timesliceEnd) {
                logsThisSecond = 0;
                timesliceEnd = currTime + 1000;
            }
            print(
            // TODO: Address the case where `breakpoint.logMessageFormat` is
            // `null`.
            breakpoint.logMessageFormat, breakpoint.evaluatedExpressions.map(function (obj) { return JSON.stringify(obj); }));
            logsThisSecond++;
            if (shouldStop()) {
                _this.listeners[breakpoint.id].enabled = false;
            }
            else {
                if (logsThisSecond >= _this.config.log.maxLogsPerSecond) {
                    _this.listeners[breakpoint.id].enabled = false;
                    setTimeout(function () {
                        // listeners[num] may have been deleted by `clear` during the
                        // async hop. Make sure it is valid before setting a property
                        // on it.
                        if (!shouldStop() && _this.listeners[breakpoint.id]) {
                            _this.listeners[breakpoint.id].enabled = true;
                        }
                    }, _this.config.log.logDelaySeconds * 1000);
                }
            }
        });
        this.listeners[breakpoint.id] = { enabled: true, listener: listener };
    };
    InspectorDebugApi.prototype.disconnect = function () {
        this.session.disconnect();
    };
    InspectorDebugApi.prototype.numBreakpoints_ = function () {
        // Tracks the number of stackdriver breakpoints.
        return Object.keys(this.breakpoints).length;
    };
    InspectorDebugApi.prototype.numListeners_ = function () {
        return Object.keys(this.listeners).length;
    };
    /**
     * Internal breakpoint set function. At this point we have looked up source
     * maps (if necessary), and scriptPath happens to be a JavaScript path.
     *
     * @param {!Breakpoint} breakpoint Debug API Breakpoint object
     * @param {!MapInfoOutput|null} mapInfo A map that has a "file" attribute for
     *    the path of the output file associated with the given input file
     * @param {function(string)=} compile optional compile function that can be
     *    be used to compile source expressions to JavaScript
     * @param {function(?Error)} cb error-back style callback
     */
    // TODO: Fix the documented types to match the function's input types
    // TODO: Unify this function with setInternal in v8debugapi.ts.
    InspectorDebugApi.prototype.setInternal = function (breakpoint, mapInfo, compile, cb) {
        // Parse and validate conditions and watch expressions for correctness and
        // immutability
        var ast = null;
        if (breakpoint.condition) {
            try {
                // We parse as ES6; even though the underlying V8 version may only
                // support a subset. This should be fine as the objective of the parse
                // is to heuristically find side-effects. V8 will raise errors later
                // if the syntax is invalid. It would have been nice if V8 had made
                // the parser API available us :(.
                ast = acorn.parse(breakpoint.condition, { sourceType: 'script', ecmaVersion: 6 });
                var validator = require('../util/validator.js');
                if (!validator.isValid(ast)) {
                    return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, utils.messages.DISALLOWED_EXPRESSION);
                }
            }
            catch (e) {
                var message = utils.messages.SYNTAX_ERROR_IN_CONDITION + e.message;
                return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_CONDITION, message);
            }
        }
        // Presently it is not possible to precisely disambiguate the script
        // path from the path provided by the debug server. The issue is that we
        // don't know the repository root relative to the root filesystem or
        // relative to the working-directory of the process. We want to make sure
        // that we are setting the breakpoint that the user intended instead of a
        // breakpoint in a file that happens to have the same name but is in a
        // different directory. Until this is addressed between the server and the
        // debuglet, we are going to assume that repository root === the starting
        // working directory.
        var matchingScript;
        // TODO: Address the case where `breakpoint.location` is `null`.
        var scripts = utils.findScripts(mapInfo ? mapInfo.file :
            path.normalize(breakpoint.location.path), this.config, this.fileStats);
        if (scripts.length === 0) {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_NOT_FOUND);
        }
        else if (scripts.length === 1) {
            // Found the script
            matchingScript = scripts[0];
        }
        else {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.SOURCE_FILE_AMBIGUOUS);
        }
        // TODO: Address the case where `breakpoint.location` is `null`.
        // TODO: Address the case where `fileStats[matchingScript]` is `null`.
        if (breakpoint.location.line >=
            this.fileStats[matchingScript].lines) {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.INVALID_LINE_NUMBER + matchingScript + ':' +
                breakpoint.location.line +
                '. Loaded script contained ' +
                this.fileStats[matchingScript].lines +
                ' lines. Please ensure' +
                ' that the snapshot was set in the same code version as the' +
                ' deployed source.');
        }
        // The breakpoint protobuf message presently doesn't have a column
        // property but it may have one in the future.
        // TODO: Address the case where `breakpoint.location` is `null`.
        var column = mapInfo && mapInfo.column ?
            mapInfo.column :
            (breakpoint.location.column || 1);
        var line = mapInfo ?
            mapInfo.line :
            breakpoint.location.line;
        // We need to special case breakpoints on the first line. Since Node.js
        // wraps modules with a function expression, we adjust
        // to deal with that.
        if (line === 1) {
            column += debugapi.MODULE_WRAP_PREFIX_LENGTH - 1;
        }
        var result = this.setAndStoreBreakpoint(breakpoint, line, column, matchingScript);
        if (!result) {
            return utils.setErrorStatusAndCallback(cb, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.V8_BREAKPOINT_ERROR);
        }
        this.breakpoints[breakpoint.id] = new BreakpointData(result.v8BreakpointId, breakpoint, ast, result.locationStr, compile);
        this.numBreakpoints++;
        setImmediate(function () {
            cb(null);
        }); // success.
    };
    InspectorDebugApi.prototype.setAndStoreBreakpoint = function (breakpoint, line, column, matchingScript) {
        // location Str will be a JSON string of Stackdriver breakpoint location.
        // It will be used as key at locationmapper to ensure there will be no
        // duplicate breakpoints at the same location.
        var locationStr = JSON.stringify(breakpoint.location);
        var v8BreakpointId; // v8/inspector breakpoint id
        if (!this.locationMapper[locationStr]) {
            // The first time when a breakpoint was set to this location.
            var res = this.v8Inspector.setBreakpointByUrl({
                lineNumber: line - 1,
                url: matchingScript,
                columnNumber: column - 1,
                condition: breakpoint.condition || undefined
            });
            if (res.error || !res.response) {
                // Error case.
                return null;
            }
            v8BreakpointId = res.response.breakpointId;
            this.locationMapper[locationStr] = [];
            this.breakpointMapper[v8BreakpointId] = [];
        }
        else {
            // Breakpoint found at this location. Acquire the v8/inspector breakpoint
            // id.
            v8BreakpointId = this.breakpoints[this.locationMapper[locationStr][0]].id;
        }
        // Adding current stackdriver breakpoint id to location mapper and
        // breakpoint mapper.
        this.locationMapper[locationStr].push(breakpoint.id);
        this.breakpointMapper[v8BreakpointId].push(breakpoint.id);
        return { v8BreakpointId: v8BreakpointId, locationStr: locationStr };
    };
    InspectorDebugApi.prototype.onBreakpointHit = function (breakpoint, callback, callFrames) {
        // Breakpoint Hit
        var start = process.hrtime();
        try {
            this.captureBreakpointData(breakpoint, callFrames);
        }
        catch (err) {
            return utils.setErrorStatusAndCallback(callback, breakpoint, status_message_1.StatusMessage.BREAKPOINT_SOURCE_LOCATION, utils.messages.CAPTURE_BREAKPOINT_DATA + err);
        }
        var end = process.hrtime(start);
        this.logger.info(utils.formatInterval('capture time: ', end));
        callback(null);
    };
    InspectorDebugApi.prototype.captureBreakpointData = function (breakpoint, callFrames) {
        var expressionErrors = [];
        var that = this;
        // TODO: Address the case where `breakpoint.id` is `null`.
        if (breakpoint.expressions && this.breakpoints[breakpoint.id].compile) {
            for (var i = 0; i < breakpoint.expressions.length; i++) {
                try {
                    // TODO: Address the case where `breakpoint.id` is `null`.
                    breakpoint.expressions[i] =
                        // TODO: Address the case where `compile` is `null`.
                        this.breakpoints[breakpoint.id].compile(breakpoint.expressions[i]);
                }
                catch (e) {
                    this.logger.info('Unable to compile watch expression >> ' +
                        breakpoint.expressions[i] + ' <<');
                    expressionErrors.push({
                        name: breakpoint.expressions[i],
                        status: new status_message_1.StatusMessage(status_message_1.StatusMessage.VARIABLE_VALUE, 'Error Compiling Expression', true)
                    });
                    breakpoint.expressions.splice(i, 1);
                    i--;
                }
            }
        }
        if (breakpoint.action === 'LOG') {
            // TODO: This doesn't work with compiled languages if there is an error
            // compiling one of the expressions in the loop above.
            if (!breakpoint.expressions) {
                breakpoint.evaluatedExpressions = [];
            }
            else {
                var frame_1 = callFrames[0];
                var evaluatedExpressions = breakpoint.expressions.map(function (exp) {
                    // returnByValue is set to true here so that the JSON string of the
                    // value will be returned to log.
                    var result = state.evaluate(exp, frame_1, that.v8Inspector, true);
                    if (result.error) {
                        return result.error;
                    }
                    else {
                        return result.object.value;
                    }
                });
                breakpoint.evaluatedExpressions = evaluatedExpressions;
            }
        }
        else {
            var captured = state.capture(callFrames, breakpoint, this.config, this.scriptMapper, this.v8Inspector);
            if (breakpoint.location &&
                utils.isJavaScriptFile(breakpoint.location.path)) {
                breakpoint.location.line = callFrames[0].location.lineNumber + 1;
            }
            breakpoint.stackFrames = captured.stackFrames;
            // TODO: This suggests the Status type and Variable type are the same.
            //       Determine if that is the case.
            breakpoint.variableTable =
                captured.variableTable;
            breakpoint.evaluatedExpressions =
                expressionErrors.concat(captured.evaluatedExpressions);
        }
    };
    InspectorDebugApi.prototype.handleDebugPausedEvent = function (params) {
        var _this = this;
        try {
            if (!params.hitBreakpoints)
                return;
            var v8BreakpointId = params.hitBreakpoints[0];
            this.breakpointMapper[v8BreakpointId].forEach(function (id) {
                if (_this.listeners[id].enabled) {
                    _this.logger.info('>>>breakpoint hit<<< number: ' + id);
                    _this.listeners[id].listener(params.callFrames);
                }
            });
        }
        catch (e) {
            this.logger.warn('Internal V8 error on breakpoint event: ' + e);
        }
    };
    return InspectorDebugApi;
}());
exports.InspectorDebugApi = InspectorDebugApi;
//# sourceMappingURL=inspector-debugapi.js.map